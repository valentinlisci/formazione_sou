Vagrant.configure("2") do |config|
  config.vm.box = "ubuntu/jammy64"

  nodes = {
    "ping1" => {ip: "192.168.56.10", memory: "1024", cpus: 1},
    "pong2" => {ip: "192.168.56.11", memory: "1024", cpus: 1}
  }

  nodes.each do |name, settings|
    config.vm.define name do |node|
      node.vm.hostname = name
      node.vm.network "private_network", ip: settings[:ip]
      node.vm.synced_folder ".", "/vagrant", disabled: true
      
      # Resource allocation
      node.vm.provider "virtualbox" do |vb|
        vb.memory = settings[:memory]
        vb.cpus = settings[:cpus]
      end
      
      node.vm.provision "shell", inline: <<-SHELL
        # Abilita debug degli script
        set -x
        
        # Aggiornamento sistema e installazione dipendenze
        apt-get update -qq
        apt-get install -y -qq docker.io sshpass net-tools # Aggiunto net-tools per netstat
        systemctl enable docker
        usermod -aG docker vagrant
        
        # --- Configurazione SSH per abilitare PasswordAuthentication in modo robusto ---
        # Crea un file di configurazione SSH dedicato per l'utente vagrant
        # Questo sovrascrive le impostazioni globali per l'utente vagrant
        echo "Match User vagrant" | sudo tee /etc/ssh/sshd_config.d/50-vagrant.conf > /dev/null
        echo "  PasswordAuthentication yes" | sudo tee -a /etc/ssh/sshd_config.d/50-vagrant.conf > /dev/null
        echo "  ChallengeResponseAuthentication yes" | sudo tee -a /etc/ssh/sshd_config.d/50-vagrant.conf > /dev/null
        echo "  UsePAM yes" | sudo tee -a /etc/ssh/sshd_config.d/50-vagrant.conf > /dev/null # Assicura che PAM sia usato
        
        # Riavvia il servizio SSH per applicare le modifiche
        systemctl restart sshd
        # --- Fine configurazione SSH ---
        
        # Configurazione SSH di base per le chiavi generate localmente
        # Queste chiavi sono per l'accesso locale o per essere scambiate
        if [ ! -f /home/vagrant/.ssh/id_rsa ]; then
          ssh-keygen -t rsa -N "" -f /home/vagrant/.ssh/id_rsa
          cat /home/vagrant/.ssh/id_rsa.pub >> /home/vagrant/.ssh/authorized_keys
        fi
        chmod 700 /home/vagrant/.ssh
        chmod 600 /home/vagrant/.ssh/authorized_keys
      SHELL
    end
  end

  # ping1 = manager
  config.vm.define "ping1" do |ping|
    ping.vm.provision "shell", inline: <<-SHELL
      set -x  # Abilita debug degli script
      
      # Inizializza Docker Swarm
      docker swarm init --advertise-addr 192.168.56.10 || {
        echo "Swarm già inizializzato, procedo..."
        docker swarm join-token -q worker > /home/vagrant/swarm_token 2>/dev/null
      }
      
      # Salva il token
      docker swarm join-token -q worker > /home/vagrant/swarm_token
      chown vagrant:vagrant /home/vagrant/swarm_token
      chmod 400 /home/vagrant/swarm_token

      # Crea servizio di esempio
      docker service create \
        --name nodo \
        --replicas 1 \
        --publish 8080:80 \
        --constraint 'node.hostname == ping1' \
        ealen/echo-server || echo "Servizio già creato"

      # Prepara lo script di rotazione
      mkdir -p /home/vagrant/nodo
      cat << 'EOF' > /home/vagrant/nodo/rotate.sh
#!/bin/bash
set -e  # Esci in caso di errore

HOSTS=("ping1" "pong2")
SERVICE="nodo"
SLEEP=60
MAX_RETRIES=3

while true; do
  for HOST in "${HOSTS[@]}"; do
    echo "Sposto il container su $HOST"
    
    for ((i=1; i<=$MAX_RETRIES; i++)); do
      if docker service update \
        --constraint-rm 'node.hostname' \
        --constraint-add "node.hostname == $HOST" \
        --force $SERVICE; then
        break
      fi
      echo "Tentativo $i fallito, riprovo..."
      sleep 5
    done
    
    sleep $SLEEP
  done
done
EOF

      chmod +x /home/vagrant/nodo/rotate.sh
      chown -R vagrant:vagrant /home/vagrant/nodo
      
      # Crea un servizio systemd
      cat << 'EOF' > /etc/systemd/system/rotate.service
[Unit]
Description=Service rotation script
After=docker.service
Requires=docker.service

[Service]
User=vagrant
ExecStart=/home/vagrant/nodo/rotate.sh
Restart=on-failure
RestartSec=5s

[Install]
WantedBy=multi-user.target
EOF
      
      systemctl daemon-reload
      systemctl enable rotate.service
      systemctl start rotate.service
    SHELL
  end

  # pong2 = worker
  config.vm.define "pong2" do |pong|
    pong.vm.provision "shell", inline: <<-SHELL
      set -x  # Abilita debug degli script
      
      # Attende che il manager sia pronto
      echo "Attendo che ping1 sia pronto..."
      until ping -c1 192.168.56.10 &>/dev/null; do
        sleep 2
      done

      # Copia la chiave pubblica di ping1 in authorized_keys di pong2
      # Usiamo sshpass ora che l'autenticazione password dovrebbe essere abilitata
      echo "Copia la chiave pubblica di ping1 su pong2..."
      TIMEOUT_KEY=90 # Aumentato il timeout per dare più tempo a ping1 di essere pronto
      while [ $TIMEOUT_KEY -gt 0 ]; do
        if sshpass -p vagrant ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null vagrant@192.168.56.10 'test -f /home/vagrant/.ssh/id_rsa.pub'; then
          break
        fi
        echo "Chiave id_rsa.pub non ancora su ping1 o SSH non pronto. Attendo..."
        sleep 5
        TIMEOUT_KEY=$((TIMEOUT_KEY-5))
      done

      if [ $TIMEOUT_KEY -le 0 ]; then
        echo "ERRORE: La chiave id_rsa.pub non è stata trovata su ping1 in tempo o la connessione SSH è fallita." >&2
        exit 1
      fi

      # Copia effettiva della chiave usando sshpass
      sshpass -p vagrant ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null vagrant@192.168.56.10 'cat /home/vagrant/.ssh/id_rsa.pub' >> /home/vagrant/.ssh/authorized_keys
      chmod 600 /home/vagrant/.ssh/authorized_keys # Assicura permessi corretti dopo l'aggiunta

      # Recupera il token con timeout
      echo "Recupero il token di swarm..."
      TIMEOUT=120
      while [ $TIMEOUT -gt 0 ]; do
        # Prova a recuperare il token, usando sshpass
        if sshpass -p vagrant ssh -o ConnectTimeout=5 -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null vagrant@192.168.56.10 \
          "cat /home/vagrant/swarm_token" > /home/vagrant/swarm_token 2>/dev/null; then
          break
        fi
        sleep 5
        TIMEOUT=$((TIMEOUT-5))
        echo "Attendo... ($TIMEOUT secondi rimanenti)"
      done

      if [ ! -f /home/vagrant/swarm_token ]; then
        echo "ERRORE: Impossibile ottenere il token di swarm. Timeout o file non trovato." >&2
        exit 1
      fi

      # Unisciti allo swarm
      JOIN_TOKEN=$(cat /home/vagrant/swarm_token)
      # Verifica che il token non sia vuoto prima di usarlo
      if [ -z "$JOIN_TOKEN" ]; then
          echo "ERRORE: Il token di join è vuoto!" >&2
          exit 1
      fi

      docker swarm join --token $JOIN_TOKEN 192.168.56.10:2377 || \
        echo "Già membro dello swarm o errore nel join."
    SHELL
  end
end
